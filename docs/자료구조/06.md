---
sidebar_position: 6
title: 연결 자료구조와 연결 리스트 (2)
description: 이중 연결 리스트와 원형 이중 연결 리스트라는 두 가지 핵심 연결 자료구조를 분석
---

## 간단 요약

단순 연결 리스트의 한계를 넘어 양방향 탐색과 순환 구조를 구현하는 이중 연결 리스트와 원형 이중 연결 리스트의 핵심 원리를 분석하고, 이를 다항식 덧셈 연산에 응용하는 방법을 구체적으로 설명합니다.

| 핵심 개념                 | 설명                                                                                                          |
| ------------------------- | ------------------------------------------------------------------------------------------------------------- |
| **이중 연결 리스트**      | 각 노드가 이전 노드와 다음 노드를 모두 가리켜 양방향 탐색이 가능한 선형 자료구조                              |
| **원형 이중 연결 리스트** | 이중 연결 리스트의 끝과 시작을 연결하여 순환적 탐색을 효율적으로 만든 자료구조                                |
| **다항식 덧셈 응용**      | 연결 리스트를 사용해 다항식의 각 항을 노드로 표현하고, 차수를 비교하며 두 다항식을 효율적으로 더하는 알고리즘 |

> **비유**: 이중 연결 리스트의 개념은 **양방향 기차놀이**에 비유할 수 있습니다.<br/>
> 기차놀이 줄에 선 각 아이(노드)가 앞사람(이전 노드)의 손과 뒷사람(다음 노드)의 손을 모두 잡고 있는 상황을 상상해 보십시오.<br/>
> 이 구조 덕분에 어느 아이든 앞이나 뒤로 쉽게 이동할 수 있으며, 이는 특정 노드에서 양쪽 방향으로 자유롭게 탐색할 수 있는 이중 연결 리스트의 직관적인 이점을 명확히 보여줍니다.

---

## 1. 이중 연결 리스트: 양방향 탐색의 구현

단순 연결 리스트는 다음 노드로 이동하기는 쉽지만, 이전 노드를 찾으려면 리스트의 처음부터 다시 탐색해야 하는 비효율적인 문제를 안고 있습니다.

이중 연결 리스트는 각 노드에 이전 노드를 가리키는 포인터를 추가함으로써 이 한계를 극복합니다. 이 구조는 데이터 탐색과 조작의 유연성을 크게 향상시켜, 더 복잡한 알고리즘을 구현하는 데 전략적으로 중요한 역할을 합니다.

### 핵심 구조 분석

이중 연결 리스트는 **양쪽 방향으로 순회할 수 있도록 노드를 연결한 리스트**로 정의할 수 있습니다.

이를 위해 각 노드는 세 가지 핵심 요소로 구성됩니다.

| 필드                   | 설명                                     |
| ---------------------- | ---------------------------------------- | --- |
| **llink** (left link)  | 왼쪽(이전) 노드를 가리키는 포인터 필드   | ˝   |
| **rlink** (right link) | 오른쪽(다음) 노드를 가리키는 포인터 필드 |
| **데이터 필드**        | 노드가 저장하는 실제 값                  |

이 두 개의 링크 필드(llink와 rlink) 덕분에 리스트의 어느 지점에서든 앞뒤로 자유롭게 이동할 수 있습니다.

### 핵심 연산 과정 해부: 노드 삽입

노드 삽입 과정을 **양방향 기차놀이** 비유로 살펴보겠습니다.

기존에 '승희'와 '상원'이 손을 잡고 서 있을 때, 그 사이에 '철이'를 끼워 넣는 상황입니다. 이 과정은 네 가지 핵심 동작으로 이루어집니다.

```text
1. 새로 들어온 '철이'는 오른손으로 '상원'의 왼손을 잡습니다. (새 노드의 rlink 설정)
2. 이어서 '철이'는 왼손으로 '승희'의 오른손을 잡습니다. (새 노드의 llink 설정)
3. '승희'는 이제 '상원'을 잡고 있던 오른손을 놓고, 대신 '철이'의 왼손을 잡습니다. (이전 노드의 rlink 변경)
4. '상원' 역시 '승희'를 잡고 있던 왼손을 놓고, 대신 '철이'의 오른손을 잡습니다. (다음 노드의 llink 변경)
```

이 과정을 통해 **승희-철이-상원** 순서로 양방향 연결이 완벽하게 재구성됩니다.

알고리즘 관점에서 노드 삽입 과정은 다음과 같은 4단계의 명확한 포인터 연산으로 정의됩니다.

> **변수 설명**: `new`는 삽입할 새 노드, `pre`는 삽입 위치의 바로 앞 노드를 의미합니다.

#### 1단계: 새 노드의 링크 설정

먼저 삽입될 `new` 노드가 기존 노드들을 가리키도록 설정합니다.

```pseudocode
new.rlink ← pre.rlink  (새 노드의 오른쪽 링크가 기존의 다음 노드를 가리키게 함)
new.llink ← pre        (새 노드의 왼쪽 링크가 기존의 이전 노드를 가리키게 함)
```

#### 2단계: 주변 노드의 링크 재설정

이제 주변 노드들이 `new` 노드를 가리키도록 포인터를 변경합니다.

> **중요**: 이 때 연산 순서가 매우 중요합니다.

```pseudocode
pre.rlink.llink ← new  (기존 다음 노드의 왼쪽 링크가 새 노드를 가리키게 함)
                       (이 작업은 pre.rlink를 바꾸기 전에 반드시 수행해야 합니다.)
pre.rlink ← new        (기존 이전 노드의 오른쪽 링크가 새 노드를 가리키게 함)
```

이 4단계의 포인터 재연결을 통해 `new` 노드가 리스트에 논리적으로 완벽하게 삽입됩니다.

### 핵심 연산 과정 해부: 노드 삭제

노드 삭제는 삽입의 역순으로, 삭제할 노드의 이전 노드와 다음 노드가 서로를 직접 가리키도록 포인터를 재연결하여 해당 노드를 논리적으로 연결에서 제외하는 과정입니다.

삭제할 노드(`old`)를 기준으로 이 과정을 살펴보겠습니다.

삭제 알고리즘의 핵심 로직은 다음 두 단계로 요약됩니다.

```pseudocode
1. 이전 노드의 포인터 변경:
   old.llink.rlink ← old.rlink
   (삭제할 노드의 이전 노드가 가진 rlink가 삭제할 노드의 다음 노드를 가리키도록 변경)

2. 다음 노드의 포인터 변경:
   old.rlink.llink ← old.llink
   (삭제할 노드의 다음 노드가 가진 llink가 삭제할 노드의 이전 노드를 가리키도록 변경)
```

### 결론 및 전환

이중 연결 리스트는 양방향 포인터를 통해 이전 노드로의 접근을 효율적으로 만들어 데이터 조작의 유연성을 극대화합니다.

이러한 구조적 장점을 바탕으로, 리스트의 시작과 끝을 연결하는 원형 구조를 도입하면 더욱 강력하고 효율적인 자료구조를 설계할 수 있습니다.

---

## 2. 원형 이중 연결 리스트: 순환 구조의 효율성

선형 자료구조는 명확한 시작과 끝이 있다는 제약을 가집니다.

원형 이중 연결 리스트는 이러한 제약을 없애고, 리스트의 마지막 노드가 첫 번째 노드를 가리키도록 하여 순환적인 데이터 관리를 가능하게 합니다. 이 구조는 데이터가 끊임없이 순환하는 환경에서 특히 강력한 성능을 발휘합니다.

### 핵심 특징 분석

원형 이중 연결 리스트는 다음과 같은 고유한 특징을 가집니다.

| 특징                             | 설명                                                                                                                                                                                                                                                                                                                                                                       |
| -------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **순환적 연결**                  | 리스트의 첫 번째 노드의 이전 포인터(prev)는 마지막 노드를 가리키고, 마지막 노드의 다음 포인터(next)는 첫 번째 노드를 가리킵니다. 이를 통해 리스트의 어느 노드에서든 순방향 또는 역방향으로 계속 순회하여 모든 노드에 접근할 수 있습니다.                                                                                                                                   |
| **양방향 탐색**                  | 이중 연결 리스트의 특성을 그대로 계승하여, 각 노드는 이전 노드와 다음 노드로의 포인터를 모두 가지고 있어 양방향 탐색이 자유롭습니다.                                                                                                                                                                                                                                       |
| **더미 노드(Dummy Node)의 활용** | 리스트의 머리(head) 부분에 실제 데이터를 저장하지 않는 '더미 노드'를 두는 것이 일반적입니다. 이 더미 노드는 리스트가 비어있을 때나 노드가 하나만 있을 때 발생하는 예외적인 경우를 처리하는 로직을 단순화합니다. 예를 들어, 빈 리스트는 더미 노드의 next와 prev 포인터가 자기 자신을 가리키는 상태로 표현되어, 삽입 및 삭제 연산을 일관된 로직으로 처리할 수 있게 해줍니다. |
| **주요 응용 분야**               | 데이터가 순환적으로 처리되어야 하는 **원형 큐(Circular Queue)** 나 **원형 버퍼(Circular Buffer)** 와 같은 자료구조를 구현하는 데 매우 유용하게 사용됩니다.                                                                                                                                                                                                                 |

### 주요 기능(Functions) 평가

원형 이중 연결 리스트는 더미 노드를 활용하여 다양한 기능을 효율적으로 구현합니다.

#### 초기화 및 상태 확인

| 함수           | 설명                                                                                                       |
| -------------- | ---------------------------------------------------------------------------------------------------------- |
| **Initialize** | 더미 노드를 생성하고, 이 노드의 next와 prev 포인터가 자기 자신을 가리키도록 하여 빈 리스트를 초기화합니다. |
| **IsEmpty**    | 더미 노드의 next 포인터가 자기 자신을 가리키는지 확인하여 리스트가 비었는지 간단히 판단합니다.             |

#### 탐색 및 순회

| 함수                     | 설명                                                                                              |
| ------------------------ | ------------------------------------------------------------------------------------------------- |
| **Search**               | 더미 노드의 다음 노드부터 시작하여 특정 데이터를 가진 노드를 순차적으로 검색합니다.               |
| **Print / PrintReverse** | 더미 노드를 기준으로 순방향(next) 또는 역방향(prev)으로 순회하며 모든 노드의 데이터를 출력합니다. |
| **Next / Prev**          | 현재 선택된 노드에서 다음 또는 이전 노드로 쉽게 이동합니다.                                       |

#### 데이터 삽입

| 함수                                              | 설명                                                                                                                                                                                                                          |
| ------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **InsertFront/<br/>InsertRear/<br/> InsertAfter** | 더미 노드 덕분에 리스트가 비어있거나, 머리 또는 꼬리에 삽입하는 모든 경우를 단일 로직으로 처리할 수 있습니다. 예를 들어, InsertFront는 더미 노드 바로 뒤에, InsertRear는 더미 노드 바로 앞에 노드를 삽입하는 것과 동일합니다. |

#### 데이터 삭제

| 함수                                       | 설명                                                                                                                                                                                      |
| ------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **RemoveFront/<br/>RemoveRear/<br/>Clear** | 삽입과 마찬가지로 더미 노드를 기준으로 포인터 연결을 재설정하여 노드를 삭제합니다. Clear 함수는 리스트가 빌 때까지 RemoveFront를 반복 호출하여 더미 노드를 제외한 모든 노드를 제거합니다. |

### 원형 이중 연결 리스트의 장점

원형 이중 연결 리스트는 순환 구조와 더미 노드를 결합하여 코드의 복잡성을 줄이고 순환 데이터 처리에 최적화된 강력한 자료구조입니다.

이제 이러한 연결 리스트 구조가 단순한 데이터 관리를 넘어, 다항식과 같은 추상적인 수학적 표현을 다루는 실제 문제 해결에 어떻게 활용될 수 있는지 살펴보겠습니다.

---

## 3. 응용 사례: 연결 리스트를 이용한 다항식 덧셈

연결 리스트는 단순한 데이터 저장을 넘어, 다항식과 같이 구조가 유동적인 추상적 수학 객체를 컴퓨터 내에서 효율적으로 표현하고 연산하는 데 탁월한 능력을 보여줍니다.

배열과 달리 항의 개수가 정해져 있지 않은 다항식을 다룰 때, 연결 리스트는 메모리를 동적으로 할당하여 필요한 만큼만 사용하므로 매우 효율적입니다.

### 다항식의 표현 방법 분석

연결 리스트를 사용하여 다항식을 표현하는 기본 원칙은 간단합니다.

다항식의 각 **항(term)** 을 하나의 **노드(node)** 로 표현하는 것입니다. 각 노드는 다음 두 개의 필드로 구성됩니다.

| 필드                   | 설명                          |
| ---------------------- | ----------------------------- |
| **coef** (coefficient) | 항의 계수를 저장합니다.       |
| **expo** (exponent)    | 항의 지수(차수)를 저장합니다. |

예를 들어, 다항식 **A(x) = 4x³ + 3x² + 5x**는 다음과 같이 3개의 노드가 연결된 리스트로 표현할 수 있습니다.

| 노드         | coef | expo |
| ------------ | ---- | ---- |
| 첫 번째 노드 | 4    | 3    |
| 두 번째 노드 | 3    | 2    |
| 세 번째 노드 | 5    | 1    |

노드들은 지수가 높은 순서부터 낮은 순서로 정렬하여 연결합니다.

### 덧셈 알고리즘 해부

두 다항식 A와 B를 더해 새로운 다항식 C를 생성하는 알고리즘은 각 다항식의 첫 번째 항부터 순차적으로 비교하며 진행됩니다.

이 과정을 위해 다항식 A, B, C의 현재 항을 가리키는 세 개의 포인터(`p`, `q`, `r`)가 사용됩니다.

알고리즘의 핵심은 두 항의 **지수 비교**에 있으며, 비교 결과에 따라 세 가지 경우로 나뉩니다.

#### 케이스 1: p.expo > q.expo (A의 지수가 더 큰 경우)

```pseudocode
1. 지수가 더 높은 p가 가리키는 항이 결과 다항식 C에 그대로 추가됩니다.
2. 포인터 p만 다음 노드로 이동하여 다음 항을 비교할 준비를 합니다.
```

#### 케이스 2: p.expo < q.expo (B의 지수가 더 큰 경우)

```pseudocode
1. 지수가 더 높은 q가 가리키는 항이 결과 다항식 C에 그대로 추가됩니다.
2. 포인터 q만 다음 노드로 이동합니다.
```

#### 케이스 3: p.expo == q.expo (두 지수가 같은 경우)

```pseudocode
1. 두 항의 계수를 더한 값(p.coef + q.coef)을 계수로,
   동일한 지수를 expo로 갖는 새로운 항을 만들어 결과 다항식 C에 추가합니다.
2. 두 항 모두 처리가 완료되었으므로, 포인터 p와 q를 모두 다음 노드로 이동시킵니다.
```

이 비교 과정은 `p`나 `q` 중 어느 하나라도 리스트의 끝에 도달할 때까지 반복됩니다.

한쪽 다항식의 모든 항이 처리되면, 다른 쪽에 남아있는 모든 항들을 결과 다항식 C의 끝에 순서대로 추가하여 덧셈을 마무리합니다.

### 실행 과정 요약

다항식 **A(x) = 4x³+3x²+5x** 와 **B(x) = 3x⁴+x³+2x+1**의 덧셈 과정을 통해 알고리즘의 작동 방식을 살펴보겠습니다.

| 단계 | 비교               | 결과                                | 설명                                                                          |
| ---- | ------------------ | ----------------------------------- | ----------------------------------------------------------------------------- |
| 1    | B의 3x⁴ vs A의 4x³ | 3x⁴ 추가                            | B의 지수가 더 높으므로 3x⁴이 결과 C에 추가됩니다.                             |
| 2    | A의 4x³ vs B의 x³  | 5x³ 추가                            | 지수가 같으므로 계수를 더한 (4+1)x³ = 5x³이 C에 추가됩니다.                   |
| 3    | A의 3x² vs B의 2x  | 3x² 추가                            | A의 지수가 더 높으므로 3x²이 C에 추가됩니다.                                  |
| 4    | A의 5x vs B의 2x   | 7x 추가                             | 지수가 같으므로 계수를 더한 (5+2)x = 7x가 C에 추가됩니다.                     |
| 5    | A 완료, B의 1 남음 | 1 추가                              | 다항식 A의 모든 항이 처리되었으므로, B에 남아있는 항 1을 C의 끝에 추가합니다. |
| 6    | 최종 결과          | **C(x) = 3x⁴ + 5x³ + 3x² + 7x + 1** |                                                                               |

---

## 결론

연결 리스트를 활용한 다항식 연산은 이 자료구조가 단순한 데이터 목록 관리를 넘어, 항의 개수가 가변적인 복잡한 수학적 문제를 얼마나 우아하고 효율적으로 해결할 수 있는지를 보여주는 대표적인 사례입니다.

이처럼 자료구조에 대한 깊이 있는 이해는 복잡한 문제 해결을 위한 강력한 도구를 제공합니다.
