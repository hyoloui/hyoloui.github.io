---
sidebar_position: 5
title: 프로세스 동기화
description: 공유 자원 관리와 임계구역 문제 해결 전략
---

## 핵심 요약 및 일상 속 예시 (Executive Summary & Real-World Analogy)

현대 운영체제 환경에서 여러 프로세스가 동시에 실행되는 **병행성(Concurrency)** 은 시스템 효율성을 극대화하지만,
**공유 자원(Shared Resource)** 에 대한 동시 접근 시 데이터의 일관성이 깨지는 경쟁 상태(Race Condition) 문제를 야기합니다.

이 문제를 해결하기 위해 공유 자원에 접근하는 코드 영역을 **임계구역(Critical Section)** 으로 설정하고, 한 번에 하나의 프로세스만 진입하도록 보장하는 **동기화(Synchronization)** 가 필수적입니다.
본 문서는 이러한 동기화 문제를 해결하기 위한 핵심 원칙을 제시하고, **세마포어(Semaphore)** 와 **모니터(Monitor)** 와 같은 대표적인 동기화 기법을 통해 데이터 무결성을 확보하는 전략을 심층적으로 분석합니다.

'임계구역'과 '상호 배제(Mutual Exclusion)'의 개념은 일상 속 주방에서의 요리 과정에 비유할 수 있습니다. 주방에는 가스레인지, 칼, 도마 등 여러 사람이 함께 사용할 수 있는 자원이 있지만, '믹서'와 같이 한 번에 한 사람만 사용해야 하는 자원도 있습니다.
만약 두 사람이 동시에 믹서를 사용하려 한다면 음식은 엉망이 될 것입니다. 여기서 '믹서'가 바로 공유 자원이며, 믹서를 사용하는 행위가 이루어지는 공간이 임계구역입니다. "한 번에 한 사람만 믹서를 사용해야 한다"는 규칙이 바로 상호 배제 원칙입니다. 이처럼 임계구역은 공유 자원의 일관성을 지키기 위해 반드시 한 번에 하나의 프로세스만 접근하도록 보호해야 하는 핵심 영역입니다.

---

## 1. 프로세스 간 통신(IPC): 협력을 위한 기반

현대의 복잡한 작업을 처리하기 위해 프로세스들은 독립적으로 실행되기보다 서로 데이터를 주고받으며 협력하는 경우가 많습니다. 이처럼 여러 프로세스가 원활하게 협력하기 위한 기반 기술이 바로 프로세스 간 통신(Inter-Process Communication, IPC)이며, 이는 병행 처리 시스템의 핵심적인 구성 요소입니다.

### IPC 개념 및 종류 분석

IPC는 실행 중인 서로 다른 프로세스 간에 데이터를 교환하고 정보를 공유하는 메커니즘을 의미합니다. 주요 IPC 기법은 다음과 같습니다.

- 공유 메모리/파일 (Shared Memory/File): 가장 원시적인 방식으로, 시스템 내의 **특정 메모리 공간이나 파일**을 여러 프로세스가 공유하여 통신합니다. 이 방식은 통신 규칙이나 데이터 교환 방법을 프로세스들이 직접 결정해야 하는 부담이 있습니다.
- 파이프 (Pipe): 운영체제가 직접 제공하는 통신 기법으로, 주로 fork() 시스템 호출을 통해 생성된 **부모와 자식 프로세스 간의 통신**에 사용됩니다. 파일 입출력과 유사한 인터페이스를 가집니다.
- 소켓 (Socket): **네트워크로 연결**된 원격지의 컴퓨터 간 통신을 위해 설계된 기법입니다. 강력한 네트워킹 기능을 제공하지만, 시스템 자원을 많이 사용하므로 동일한 컴퓨터 내의 프로세스 간 통신에는 비효율적일 수 있습니다.

### IPC 방식 분류

IPC는 통신 방향과 구현 방식이라는 두 가지 기준으로 분류할 수 있습니다.

### 통신 방향에 따른 분류

- 양방향 통신 (Duplex): 데이터가 양쪽 방향으로 동시에 전송될 수 있는 구조입니다. 소켓 통신이 대표적인 예시이며, 우리가 일상에서 사용하는 전화기와 유사합니다.
- 반양방향 통신 (Half-duplex): 양방향 전송이 가능하지만, 특정 시점에는 한쪽 방향으로만 데이터가 흐를 수 있습니다. 무전기처럼 한쪽이 말을 마쳐야 다른 쪽이 말할 수 있는 방식입니다.
- 단방향 통신 (Simplex): 데이터가 오직 한쪽 방향으로만 전송되는 구조입니다. 모스 부호처럼 송신자와 수신자가 명확히 구분됩니다. 표준 파이프는 단방향 채널이지만, 두 개의 파이프를 사용하면 양방향 통신 구현이 가능합니다.

통신 구현 방식에 따른 분류

- 대기가 있는 통신 (Blocking/Synchronous): 동기화를 지원하는 방식으로, 데이터를 받는 프로세스는 데이터가 도착할 때까지 자동으로 대기 상태에 들어갑니다. 파이프와 소켓이 대표적인 동기식 통신 방식입니다.
- 대기가 없는 통신 (Non-blocking/Asynchronous): 동기화를 지원하지 않는 방식으로, 데이터를 받는 프로세스가 능동적으로 데이터 도착 여부를 계속 직접 확인해야 합니다. 공유 메모리나 파일을 이용한 통신이 비동기식 방식에 해당합니다.

IPC는 이처럼 다양한 방식으로 프로세스 간의 협력을 가능하게 하는 필수적인 도구입니다. 그러나 여러 프로세스가 협력을 위해 동시에 실행되는 '병행성' 환경은 공유된 자원에 대한 접근 충돌이라는 또 다른 문제를 야기하며, 이는 동기화의 필요성으로 이어집니다.

## 2. 공유 자원과 경쟁 상태: 병행성의 그림자

여러 프로세스가 동시에 실행되는 병행성(Concurrency)은 시스템의 처리 속도를 높이고 자원 활용도를 극대화하는 중요한 개념입니다.
하지만 이러한 환경은 여러 프로세스가 **하나의 자원을 동시에 사용**하려 할 때 심각한 충돌을 일으킬 수 있으며,
이는 시스템의 안정성을 저해하는 주된 원인이 됩니다.

### 핵심 문제 정의

- 공유 자원 (Shared Resource): 여러 프로세스가 공동으로 접근하여 사용하는 변수, 메모리, 파일 등을 의미합니다. 공유 자원은 어떤 프로세스가 언제, 어떻게 접근하느냐에 따라 최종 결과가 예측 불가능하게 달라질 수 있는 잠재적 위험을 내포합니다.
- 경쟁 상태 (Race Condition): 둘 이상의 프로세스가 공유 자원에 동시에 접근하여 조작할 때, 어느 프로세스가 먼저 접근했는지 그 실행 순서에 따라 결과가 달라지는 현상입니다. 경쟁 상태가 발생하면 데이터의 일관성과 결과의 신뢰성을 보장할 수 없게 됩니다.
  - 예시: 은행 예금 문제
    - 초기 예금 잔액이 10만 원인 계좌가 있습니다.
    - 프로세스 P1은 10만 원을 입금하고, 프로세스 P2는 5만 원을 입금하려 합니다.
    - P1이 잔액(10만 원)을 읽고 덧셈(10+10=20)을 수행한 직후, 운영체제 스케줄러에 의해 **문맥 교환(context switch)**이 발생하여 P2가 실행되었다고 가정해 봅시다.
    - P2 역시 P1이 갱신하기 전의 원래 잔액(10만 원)을 읽고 덧셈(10+5=15)을 수행한 후, 그 결과를 메모리에 저장하면 잔액은 15만 원이 됩니다.
    - 이후 다시 P1이 실행되어 이전에 계산해 둔 20만 원을 저장하면, P2의 작업은 무시되고 잔액은 20만 원이 됩니다. 최종 잔액은 25만 원이 되어야 하지만, 실행 순서에 따라 15만 원 또는 20만 원이라는 잘못된 결과가 나옵니다.
- 임계구역 (Critical Section): 공유 자원에 접근하는 코드 영역, 즉 경쟁 상태를 유발할 수 있는 프로그램의 특정 부분을 지칭합니다. 데이터의 무결성을 보장하기 위해, 임계구역은 반드시 한 번에 단 하나의 프로세스만 실행하도록 보호되어야 합니다.

### 대표적 문제 사례 분석: 생산자-소비자 문제

생산자-소비자 문제는 병행 처리 환경에서 발생하는 고전적인 동기화 문제입니다. 이 시나리오에서 '생산자' 프로세스는 데이터를 생성하여 공유 버퍼에 채우고, '소비자' 프로세스는 공유 버퍼에서 데이터를 가져와 사용합니다. 이때 공유 버퍼는 두 프로세스가 동시에 접근할 수 있는 임계구역입니다. 만약 두 프로세스의 버퍼 접근이 동기화되지 않으면, 실행 순서에 따라 최종 데이터의 합계(sum 값)가 2가 되기도 하고 4가 되기도 하는 등 예측 불가능한 결과가 발생하여 시스템의 신뢰성을 심각하게 훼손합니다.

이처럼 경쟁 상태와 임계구역 문제는 병행 프로그래밍에서 반드시 해결해야 할 과제입니다. 이 문제를 체계적으로 해결하기 위해서는 모든 해결책이 공통적으로 만족해야 하는 엄격한 원칙들이 존재합니다.

## 3. 임계구역 문제 해결의 원칙

안정적인 병행 프로그래밍을 구현하기 위해, 임계구역 문제를 해결하는 모든 동기화 기법은 반드시 아래의 세 가지 핵심 원칙을 준수해야 합니다. 이 원칙들은 동기화 메커니즘의 정합성을 평가하는 기준이자, 신뢰할 수 있는 시스템을 구축하는 근간이 됩니다.

필수 조건 분석

- 상호 배제 (Mutual Exclusion)
  - 정의: 한 프로세스가 자신의 임계구역을 실행하고 있다면, 다른 어떤 프로세스도 자신의 임계구역에 진입할 수 없어야 합니다.
  - 의미: 이는 임계구역의 독점적 사용을 보장하는 가장 기본적인 원칙으로, 공유 자원에 대한 동시 접근을 원천적으로 차단하여 경쟁 상태를 방지하고 데이터의 일관성을 유지합니다.
- 한정 대기 (Bounded Waiting)
  - 정의: 어떤 프로세스도 임계구역에 진입하기 위해 **무한 대기(infinite postpone)**해서는 안 됩니다. 즉, 임계구역 진입 요청 후에는 유한한 시간 내에 반드시 해당 요청이 허가되어야 합니다.
  - 의미: 특정 프로세스가 자원을 할당받지 못하고 계속해서 대기하는 **기아 상태(Starvation)**를 방지하여 모든 프로세스가 공평하게 실행될 기회를 갖도록 보장합니다.
- 진행의 융통성 (Progress Flexibility)
  - 정의: 한 프로세스가 다른 프로세스의 진행을 방해해서는 안 됩니다.
  - 의미: 더 정확하게는, **임계구역 외부(non-critical section)**에서 실행 중인 프로세스가 다른 프로세스들의 임계구역 진입을 방해해서는 안 된다는 원칙입니다. 임계구역이 비어 있고 진입을 원하는 프로세스가 존재한다면, 반드시 어느 프로세스든 진입이 허용되어야 함을 의미하며, 이는 시스템 전체의 처리 효율을 보장합니다.

이 세 가지 원칙은 모든 동기화 알고리즘과 기법이 갖추어야 할 필수 요건입니다. 이제 이러한 원칙들을 바탕으로 임계구역 문제를 해결하는 구체적인 기법들을 살펴보겠습니다.

## 4. 임계구역 문제 해결 기법: 동기화 메커니즘

임계구역 문제를 해결하고 앞서 제시된 세 가지 원칙을 구현하기 위해 다양한 방법론이 개발되었습니다. 이러한 기법들은 단순한 소프트웨어 알고리즘부터 하드웨어의 직접적인 지원을 받는 방식, 그리고 운영체제 수준에서 제공되는 고수준의 동기화 도구에 이르기까지 다양합니다.

### 소프트웨어 및 하드웨어 기반 해결책

- 소프트웨어적 해결책: 데커(Dekker) 알고리즘과 피터슨(Peterson) 알고리즘은 특별한 하드웨어 명령어 없이 상호 배제를 구현한 초기 소프트웨어 기법입니다. 피터슨 알고리즘은 데커 알고리즘을 개선한 형태로, 임계구역 문제 해결의 세 가지 조건을 모두 만족시킵니다. 하지만 이 두 알고리즘은 단 두 개의 프로세스 간의 동기화만 지원한다는 명확한 한계를 가집니다.
- 하드웨어적 해결책: 검사와 지정(test-and-set)과 같은 하드웨어 명령어는 상호 배제를 효과적으로 지원합니다. 이 명령어는 특정 메모리 위치의 값을 확인하고 새로운 값으로 수정하는 두 가지 작업을 **원자적(atomic)** 으로, 즉 누구에게도 방해받지 않고 한 번에 실행합니다. 이를 통해 명령어 실행 도중에 문맥 교환이 발생하여 임계구역 보호에 실패하는 문제를 원천적으로 방지합니다.

### 세마포어(Semaphore) 분석

세마포어는 컴퓨터 과학자 다익스트라(E. J. Dijkstra)가 제안한 고전적이면서도 강력한 동기화 도구입니다. 세마포어는 현재 사용 가능한 자원의 수를 나타내는 정수 변수(소스 코드 예시에서는 RS)와 두 개의 원자적 연산인 P와 V로 동작합니다.

- P 연산 (wait): 프로세스가 임계구역에 진입하기 전에 호출하는 연산입니다. 사용 가능한 자원이 있는지 확인하여, 자원이 있으면 그 수를 1 감소시키고 임계구역으로 진입합니다. 만약 자원이 없다면(0 이하), 자원이 생길 때까지 프로세스는 대기 상태에 들어갑니다.
- V 연산 (signal): 프로세스가 임계구역에서의 작업을 마치고 나올 때 호출하는 연산입니다. 자원을 반납하는 의미로 자원의 수를 1 증가시키고, 혹시 자원을 기다리며 대기 중인 다른 프로세스가 있다면 wake_up 신호를 보내 깨워줍니다.

앞서 언급된 은행 예금 문제는 세마포어를 통해 간단히 해결할 수 있습니다. P1이 임계구역에 진입하기 전 P() 연산을 호출하면 자원은 0이 되어 잠깁니다. 이때 P2가 진입을 시도하며 P()를 호출하면 자원이 없으므로 대기하게 됩니다. P1이 작업을 마치고 V() 연산을 호출하여 자원을 반납하고 P2를 깨워주면, 그제야 P2가 임계구역에 진입할 수 있습니다. 이처럼 세마포어는 P와 V 연산을 통해 프로세스 실행 순서를 제어하여 경쟁 상태를 완벽하게 방지합니다.

### 모니터(Monitor) 분석

모니터는 세마포어보다 한 단계 더 추상화된 고수준의 동기화 도구입니다. 세마포어 사용 시 개발자가 P와 V 연산을 잘못된 순서로 호출하거나 누락하여 버그를 만드는 실수를 방지하기 위해 고안되었습니다.

모니터의 핵심 원리는 캡슐화입니다. 공유 자원과 해당 자원에 접근할 수 있는 연산(프로시저)들을 하나의 모듈로 묶어 내부적으로 숨깁니다. 외부 프로세스는 오직 모니터가 제공하는 정해진 인터페이스(프로시저)를 통해서만 자원에 접근할 수 있으며, 모니터 자체가 내부적으로 한 번에 하나의 프로세스만 활성화되도록 보장합니다. 이러한 구조는 상호 배제를 언어 차원에서 구현해주므로, 개발자는 동기화의 복잡한 세부 사항을 신경 쓰지 않고도 안전하게 공유 자원을 사용할 수 있습니다. 이처럼 모니터는 동기화 구현의 책임을 프로그래머로부터 컴파일러와 런타임 시스템으로 이전시켜, 더욱 안전하고 신뢰성 높은 병행 프로그래밍을 가능하게 합니다.

---

이처럼 병행 시스템의 안정성을 보장하기 위한 동기화 메커니즘은 로우레벨의 소프트웨어 알고리즘과 하드웨어 명령어에서부터 시작하여, 세마포어와 같이 운영체제가 제공하는 강력한 도구를 거쳐, 모니터와 같은 고수준의 언어적 추상화로 발전해왔습니다. 이러한 정교한 메커니즘들은 현대 운영체제가 복잡한 다중 프로세스 환경을 안정적으로 관리하고 사용자에게 원활한 컴퓨팅 경험을 제공하는 기술적 토대가 됩니다.
