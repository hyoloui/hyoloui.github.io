---
sidebar_position: 7
title: "물리 메모리 관리"
description: "시스템의 전반적인 성능과 안정성을 좌우하는 가장 핵심적인 기능인 물리 메모리 관리"
---

> **핵심 요약**  
> 운영체제 아키텍처에서 물리 메모리 관리는 시스템의 전반적인 성능과 안정성을 좌우하는 가장 핵심적인 기능입니다. 컴퓨터의 주기억장치(Main Memory)는 한정된 자원이지만, 다수의 프로세스가 동시에 실행되기 위해서는 이 공간을 효율적으로 공유하고 관리해야 합니다.

## 서문: 개요 및 핵심 비유

운영체제는 어떤 프로세스에 메모리를 할당하고, 언제 회수하며, 각 프로세스가 서로의 영역을 침범하지 않도록 보호할 것인지를 결정하는 복잡한 역할을 수행합니다. 이 관리 방식의 효율성이 곧 시스템 전체의 응답성과 처리 능력으로 직결됩니다.

### 운영체제 메모리 관리의 핵심 원리

운영체제 메모리 관리의 핵심 원리를 다음과 같이 요약합니다:

- **기억장치의 계층 구조**: 컴퓨터 시스템은 속도, 용량, 비용이 각기 다른 기억장치들을 계층적으로 구성하여 사용합니다. 운영체제는 이 구조를 이해하고 데이터를 적절히 배치하여 성능을 최적화합니다.
- **주소 공간의 분리**: 운영체제는 사용자 프로세스가 직접 물리 메모리에 접근하는 것을 막기 위해 논리 주소와 물리 주소를 분리합니다. 이 메커니즘은 메모리를 보호하고 프로그램의 실행 효율을 높이는 기반이 됩니다.
- **연속 및 비연속 할당**: 메모리 할당은 프로세스를 통째로 배치하는 연속 할당(세그먼테이션)과 조각내어 배치하는 비연속 할당(페이징)으로 나뉘며, 각각 외부 및 내부 단편화라는 고유한 최적화 과제를 가집니다.
- **핵심 관리 전략**: 메모리 관리자는 **반입(Fetch)**, **배치(Placement)**, **교체(Replacement)** 라는 세 가지 핵심 전략을 통해 보조기억장치의 프로세스를 주기억장치로 가져오고, 적절한 위치에 배치하며, 공간이 부족할 경우 기존 프로세스를 내보내는 작업을 체계적으로 수행합니다.

### 비유로 이해하는 메모리 관리

> **메모리 관리의 비유**  
> 메모리를 **도마**, 그리고 실행될 프로세스를 **요리 재료**라고 생각해 보십시오. 요리사(프로세스)는 가능한 한 넓은 도마를 독차지하여 편하게 작업하고 싶어 합니다. 하지만 주방 관리자(메모리 관리자)는 한정된 도마 공간에 여러 재료를 효율적으로 올려놓고, 작업 순서에 따라 재료를 올리거나 치우면서 주방 전체의 작업 흐름이 막히지 않도록 관리해야 합니다. 이처럼 상충하는 두 가지 관점 사이에서 최적의 균형점을 찾는 것이 메모리 관리의 본질입니다.

---

## 1. 컴퓨터 기억장치의 기본 구조와 원리

컴퓨터 아키텍처의 핵심을 이해하려면 기억장치 계층 구조의 개념부터 파악해야 합니다. 시스템 설계는 **속도**, **용량**, **비용**이라는 세 가지 상충하는 요소 간의 트레이드오프를 최적화하는 과정입니다. 기억장치 계층 구조는 이 문제에 대한 아키텍처적 해법으로, CPU가 자주 접근하는 데이터는 빠르고 비싼 상위 계층에, 그렇지 않은 데이터는 느리고 저렴한 하위 계층에 배치하여 시스템 전반의 성능과 비용 효율성을 동시에 달성합니다.

### 기억장치 계층 구조

컴퓨터의 기억장치 계층 구조는 일반적으로 다음과 같이 구성됩니다. 상위 계층으로 갈수록 비트당 가격이 높고, 용량은 작아지며, 접근 시간은 짧아지고, CPU의 접근 빈도는 높아집니다.

| 계층                           | 설명                                                                                                                                |
| ------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------- |
| **레지스터 (Register)**        | CPU 내부에 존재하는 가장 빠른 기억장치입니다. 용량이 매우 작지만 CPU가 직접 연산에 사용하는 데이터를 저장합니다.                    |
| **캐시 메모리 (Cache Memory)** | CPU와 주기억장치 사이에 위치하여 속도 차이를 완화하는 역할을 합니다. CPU가 자주 사용할 것으로 예상되는 데이터를 미리 저장해 둡니다. |
| **주기억장치 (Main Memory)**   | 흔히 **RAM**이라고 불리며, 현재 실행 중인 프로그램의 코드와 데이터가 저장되는 작업 공간입니다.                                      |
| **디스크 캐시 (Disk Cache)**   | 주기억장치와 디스크 사이에 위치하여 디스크 입출력 성능을 향상시키는 데 사용됩니다.                                                  |
| **디스크 (Disk)**              | 하드 디스크(HDD), SSD 등 영구적인 데이터 저장을 위한 보조기억장치입니다.                                                            |
| **자기 테이프 및 CD-ROM**      | 데이터 백업이나 장기 보관을 위해 사용되는 외부 기억장치입니다.                                                                      |

### 내부 기억장치 vs 외부 기억장치

이러한 계층은 크게 **내부 기억장치**와 **외부 기억장치**로 구분할 수 있습니다. 두 유형의 핵심적인 차이는 다음과 같습니다.

| 구분          | 내부 기억장치 (Internal Memory)                        | 외부 기억장치 (External Memory)                                 |
| ------------- | ------------------------------------------------------ | --------------------------------------------------------------- |
| **정의**      | CPU와 직접적으로 통신하는 기억장치                     | 주기억장치 외부에 위치한 보조적인 기억장치                      |
| **목적**      | 실행 중인 프로그램 코드, 데이터, 임시 데이터 등을 저장 | 대용량 데이터나 영구적인 저장이 필요한 데이터를 장기적으로 보관 |
| **대표 예시** | 레지스터, 캐시 메모리, RAM, 플래시 메모리              | 하드 디스크, SSD, USB, 네트워크 저장장치(NAS), 클라우드 저장소  |

> **다음 단계**  
> 기억장치의 물리적 구조를 이해했으니, 이제 운영체제가 이 한정된 자원을 어떻게 효율적으로 관리하는지에 대한 구체적인 전략을 다룰 차례입니다.

---

## 2. 메모리 관리의 3대 핵심 전략

메모리 관리자는 세 가지 기본 전략인 **반입(Fetch)**, **배치(Placement)**, **교체(Replacement)** 를 통해 지속적인 의사결정을 내리는 엔진으로 작동합니다. 이는 개별적인 작업이 아니라, 프로세스의 흐름을 통제하고 시스템 처리량과 응답성에 직접적인 영향을 미치는 상호 연결된 제어 시스템입니다. 이 시스템은 보조기억장치의 프로세스를 **언제**, **어디로** 가져올지, 그리고 메모리가 포화 상태일 때 **어떤** 프로세스를 내보낼지를 결정합니다.

### 반입 전략 (Fetch Strategy)

반입 전략은 보조기억장치에 있는 프로세스나 데이터를 주기억장치로 **'언제'** 가져올지를 결정하는 정책입니다.

- **요구 반입 (Demand Paging)**: 프로세스가 실행 중 특정 데이터를 실제로 요청하고 필요로 할 때 해당 부분(페이지)만 메모리로 가져오는 방식입니다.
- **예상 반입 (Anticipatory Paging)**: 프로세스가 앞으로 필요로 할 것이라고 예상되는 데이터까지 미리 메모리로 가져오는 방식입니다.

### 배치 전략 (Placement Strategy)

배치 전략은 반입 전략에 의해 메모리로 가져온 프로세스나 데이터를 주기억장치의 **'어디에'** 위치시킬지를 결정하는 정책입니다.

- **최초 적합 (First Fit)**: 메모리의 빈 공간을 순서대로 검색하다가, 프로세스를 수용할 수 있는 충분한 크기의 첫 번째 공간에 바로 할당하는 방식입니다.
- **최적 적합 (Best Fit)**: 메모리의 모든 빈 공간을 확인한 후, 프로세스 크기에 가장 근접한(가장 작은) 공간에 할당합니다. 이 방식의 목표는 할당 후 남는 조각의 크기를 최소화하는 것입니다.
- **최악 적합 (Worst Fit)**: 메모리의 모든 빈 공간을 확인한 후, 가장 큰 공간에 프로세스를 할당하는 방식입니다. 이 경우 남는 공간이 커서 다른 프로세스가 활용하기 용이할 수 있습니다.

### 교체 전략 (Replacement Strategy)

교체 전략은 주기억장치 공간이 모두 사용되어 새로운 프로세스를 가져올 공간이 없을 때, **'어떤'** 기존 프로세스(또는 페이지)를 보조기억장치로 내보낼지를 결정하는 정책입니다. 이 결정은 **페이지 부재(Page Fault)** 가 발생했을 때 중요하게 작용합니다.

- 주요 기법으로는 **LRU(Least Recently Used)**, **LFU(Least Frequently Used)**, **NUR(Not Used Recently)** 등 다양한 알고리즘이 사용됩니다.

> **다음 단계**  
> 이러한 전략이 실제로 적용되기 위해 운영체제가 사용하는 핵심적인 주소 변환 메커니즘에 대해 다음 섹션에서 알아보겠습니다.

---

## 3. 주소 공간의 분리: 논리 주소와 물리 주소

현대 시분할 시스템에서 메모리 관리가 복잡한 이유는 여러 응용 프로그램이 동시에 메모리에 상주하기 때문입니다. 만약 모든 프로그램이 메모리의 실제 물리 주소에 직접 접근한다면, 한 프로그램의 오류가 다른 프로그램이나 운영체제 자체를 손상시킬 수 있습니다. 이 문제를 해결하고 메모리 보호와 프로그램 이식성을 향상시키는 핵심 아키텍처가 바로 **논리 주소**와 **물리 주소**의 분리입니다.

### 논리 주소 vs 물리 주소

| 구분          | 논리 주소 (Logical Address)                                                                  | 물리 주소 (Physical Address)                                                     |
| ------------- | -------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------- |
| **관점**      | 사용자 프로세스 입장에서 바라보는 주소                                                       | 하드웨어, 즉 메모리 입장에서 바라보는 실제 주소                                  |
| **특징**      | 각 프로세스마다 독립적인 주소 공간을 가지며, 항상 0번지부터 시작하는 상대적인 주소 체계      | 컴퓨터에 장착된 RAM의 실제 하드웨어 주소                                         |
| **사용 목적** | 프로그래머가 메모리의 실제 구조를 신경 쓰지 않고 프로그램을 작성할 수 있도록 함. 이식성 증대 | 메모리 주소 레지스터가 데이터를 읽고 쓰기 위해 최종적으로 사용하는 절대적인 주소 |

### 주소 변환 과정

사용자 프로세스가 사용하는 논리 주소는 실행 시점에 하드웨어인 **메모리 관리 유닛(MMU, Memory Management Unit)** 에 의해 실제 물리 주소로 동적으로 변환됩니다. 이 과정은 다음과 같습니다:

1. **논리 주소 요청**: 사용자 프로세스가 특정 데이터에 접근하기 위해 논리 주소(예: 40번지)를 CPU에 요청합니다.
2. **MMU 전달**: CPU는 이 요청을 받아 메모리 관리 유닛(MMU)에 전달합니다.
3. **물리 주소 변환**: MMU는 **'재배치 레지스터(Relocation Register)'** 에 저장된 프로세스의 시작 주소 값을 논리 주소에 더하여 물리 주소로 변환합니다. 예를 들어, 재배치 레지스터 값이 360이라면, 논리 주소 40번지는 물리 주소 400번지 (360 + 40)로 변환되어 메모리에서 실제 데이터를 가져옵니다.

### 메모리 보호 메커니즘

운영체제는 시스템 안정성을 위해 자신의 핵심 코드가 저장된 영역을 사용자 프로세스로부터 반드시 보호해야 합니다. 이 역할을 수행하는 것이 **경계 레지스터(Boundary Register)** 입니다. 이 레지스터는 사용자 영역이 끝나는 경계 주소를 저장합니다.

사용자 프로세스가 메모리 접근을 요청할 때마다 MMU는 요청된 논리 주소에 재배치 레지스터 값을 더한 최종 물리 주소가 경계 레지스터가 정의한 합법적인 사용자 영역 내에 있는지 검사합니다. 만약 이 범위를 벗어나는 접근 시도가 감지되면, MMU는 이를 하드웨어 수준에서 차단하고 해당 프로세스를 강제 종료시켜 시스템 전체를 보호합니다.

> **다음 단계**  
> 주소 변환의 원리를 이해했으므로, 이제 이 원리를 바탕으로 실제 메모리를 어떻게 분할하고 할당하는지에 대한 구체적인 기법들을 다음 섹션에서 상세히 검토하겠습니다.

---

## 4. 메모리 할당 및 분할 기법

운영체제는 메모리 사용 효율성과 관리의 복잡성 사이에서 최적의 균형을 찾기 위해 다양한 할당 및 분할 기법을 사용합니다. 이 기법들은 크게 프로세스를 하나의 덩어리로 취급하는 **'연속 할당'** 과, 여러 조각으로 나누어 배치하는 **'비연속 할당'** 으로 나뉩니다. 이 두 접근법의 선택은 전형적인 아키텍처적 트레이드오프를 보여줍니다. 세그먼테이션은 논리적 일관성을 제공하지만 복잡한 메모리 관리와 외부 단편화 비용을 치르고, 페이징은 단순하고 예측 가능한 관리를 제공하지만 내부 단편화를 통한 메모리 낭비 가능성을 감수합니다.

### 핵심 할당 기법 분석

#### 가변 분할 방식 (세그먼테이션)

- **개념**: 프로세스가 필요한 크기만큼 메모리를 동적으로 할당하는 연속 메모리 할당 방식입니다. 프로세스는 메모리상에서 하나의 연속된 덩어리로 관리됩니다.
- **장점**: 프로세스를 논리적인 하나의 단위로 다룰 수 있습니다.
- **단점과 해결책**: 프로세스가 메모리에 할당되고 해제되는 과정이 반복되면, 사용되지 않는 작은 빈 공간들이 메모리 곳곳에 흩어집니다. 이를 **외부 단편화(External Fragmentation)** 라고 합니다. 이 문제를 해결하기 위해 운영체제는 두 가지 접근법을 사용합니다:
  - **예방적 조치 (선처리)**: 메모리 배치 방식(최초/최적/최악 적합)을 통해 처음부터 단편화 발생을 최소화하는 방향으로 프로세스를 배치합니다.
  - **사후 해결책 (후처리)**: 흩어진 조각들을 모아 하나의 큰 공간으로 만드는 **조각 모음(Defragmentation)** 작업을 주기적으로 수행합니다.

#### 고정 분할 방식 (페이징)

- **개념**: 물리 메모리를 미리 **'페이지(Page)'** 라는 고정된 크기의 조각으로 나누어두고, 프로세스 또한 동일한 크기의 조각으로 나누어 비연속적으로 할당하는 비연속 메모리 할당 방식입니다.
- **장점**: 메모리를 일정한 크기로 관리하므로 관리가 수월하고 외부 단편화가 발생하지 않습니다.
- **단점**: 프로세스의 크기가 페이지 크기의 배수가 아닐 경우, 마지막 페이지에는 사용되지 않는 공간이 남게 됩니다. 이를 **내부 단편화(Internal Fragmentation)** 라고 하며, 이로 인해 메모리 낭비가 발생할 수 있습니다.

### 고급 기법: 버디 시스템(Buddy System)

버디 시스템은 가변 분할과 고정 분할 방식의 특징을 결합한 하이브리드 기법입니다.

- **작동 방식**: 프로세스의 크기에 맞춰 메모리를 1/2 크기로 반복해서 분할하여 할당합니다. 프로세스가 종료되면, 분할되었던 인접한 빈 공간(버디)과 다시 통합하여 더 큰 덩어리로 만듭니다. 이 방식은 비슷한 크기의 조각들을 효율적으로 통합할 수 있지만, 할당된 구역 내부에 사용되지 않는 공간이 생겨 내부 단편화가 발생할 수 있습니다.

### 보조 기법

- **메모리 오버레이 (Memory Overlay)**: 실제 물리 메모리보다 큰 프로그램을 실행하기 위한 초기 기법입니다. 전체 프로그램을 메모리에 올리는 대신, 프로그램을 기능별 모듈로 조각내어 현재 실행에 필요한 부분만 메모리에 적재하여 실행합니다.
- **스와핑 (Swapping)**: 주기억장치의 공간이 부족할 때, 현재 사용되지 않는 프로세스를 보조기억장치 내의 특별한 공간인 **'스왑 영역(Swap Area)'** 으로 일시적으로 내보내고(**Swap Out**), 나중에 필요할 때 다시 주기억장치로 불러오는(**Swap In**) 기법입니다. 이를 통해 실제 물리 메모리보다 더 큰 가상 메모리 공간을 제공할 수 있습니다.

---

## 5. 결론

운영체제가 한정된 물리 메모리 자원을 관리하기 위해 사용하는 핵심 아키텍처 원리들을 분석했습니다. 컴퓨터의 기억장치 계층 구조는 비용과 성능의 균형을 맞추는 물리적 기반을 제공하며, 운영체제는 **반입**, **배치**, **교체**라는 관리 전략을 통해 이 자원을 동적으로 제어합니다.

논리 주소와 물리 주소의 분리 및 변환 메커니즘은 현대 다중 프로그래밍 환경에서 메모리 보호와 효율적인 자원 공유를 가능하게 하는 근간 기술입니다. 이를 바탕으로 프로세스 크기에 맞춰 할당하는 **가변 분할(세그먼테이션)** 과 메모리를 고정된 크기로 나누어 관리하는 **고정 분할(페이징)** 같은 구체적인 분할 기법이 적용되며, 각 방식은 단편화라는 고유의 트레이드오프를 가집니다.

궁극적으로, 정교한 메모리 관리 아키텍처는 단순히 하나의 기능이 아닙니다. 이는 오늘날 모든 고성능, 안정성, 보안을 갖춘 컴퓨팅이 구축되는 양보할 수 없는 기반입니다. 효율적인 메모리 관리는 시스템의 안정성을 보장하고, 응답 속도를 결정하며, 다중 작업을 원활하게 처리하는 능력 그 자체를 정의합니다.
