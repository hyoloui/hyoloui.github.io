---
sidebar_position: 5
title: 컴퓨터 산술과 논리연산(2)
description: 컴퓨터의 산술 및 논리 연산과 제어 유닛의 주요 테마, 개념 및 중요 사실을 요약하고 설명
---

## 1. 컴퓨터 산술과 논리 연산

컴퓨터의 핵심 기능 중 하나는 **수치 산술 연산**과 **논리 연산** 입니다. 이 연산들은 주로 CPU의 **산술논리연산장치(ALU)** 에서 처리됩니다.

### 1.1 정수의 산술 연산

- **덧셈, 뺄셈, 곱셈, 나눗셈** 등 기본 연산을 수행
- **부호 없는 정수의 곱셈**
  - 각 비트별로 부분 곱(partial product) 계산 후 모두 더함
  - **하드웨어:**
    - M 레지스터(피승수), Q 레지스터(승수), 결과는 A+Q 레지스터에 저장
- **부호 있는 정수의 곱셈**
  - 2의 보수 곱셈에 **Booth 알고리즘** 사용
  - 하드웨어에 보수기와 Q-1 레지스터 추가
- **나눗셈**
  - `$A \div B = q \cdots r$` (A: 피제수, B: 제수, q: 몫, r: 나머지)
  - 부호 없는 2진 나눗셈, 2의 보수 나눗셈 모두 사용

### 1.2 부동소수점 수의 표현

- **개념:** 소수점 위치를 이동시켜 넓은 수 표현 범위 제공
- **일반형:** `$N = (-1)^S \times M \times B^E$` (S: 부호, M: 가수, B: 기수, E: 지수)
- **종류:** 10진/2진 부동소수점
- **정밀도:**
  - 단일-정밀도(32비트): S(1), E(8), M(23)
  - 복수-정밀도(64비트): S(1), E(11), M(52)
- **정규화(normalized):** `$\pm 1.fff...f \times 2^E$` (소수점 아래 첫 비트는 항상 1, hidden bit)
- **바이어스 지수:** 지수에 바이어스 값 더해 저장, 크기 비교/0-검사 용이
- **표현 범위:**
  - 단일-정밀도: 약 `$1.47 \times 10^{-39}$ ~ $1.7 \times 10^{38}$`
  - 예외: 지수/가수 오버플로우, 언더플로우
- **IEEE 754 표준:**
  - 32비트: `$N = (-1)^S 2^{E-127} (1.M)$`
  - 64비트: `$N = (-1)^S 2^{E-1023} (1.M)$`
  - NaN, 무한대, 0 등 예외 처리 포함

### 1.3 부동소수점 산술 연산

- **덧셈/뺄셈:**
  1. 지수 일치(정렬)
  2. 가수 연산(덧셈/뺄셈)
  3. 결과 정규화
- **곱셈:** 가수 곱, 지수 합, 정규화
- **나눗셈:** 가수 나눗셈, 지수 차, 정규화
- **파이프라이닝:** 연산을 여러 단계로 분리해 속도 향상(슈퍼컴퓨터 등에서 활용)
- **문제점:** 지수/가수 오버플로우, 언더플로우 등 예외 발생 가능

---

## 2. 제어 유닛(Control Unit)

제어 유닛은 CPU가 명령어를 **인출, 해독, 실행** 하는 모든 과정을 제어 신호로 변환해 순차적으로 발행하는 핵심 구성 요소입니다.

### 2.1 주요 기능 및 용어

- **명령어 해독:** 명령어 코드 해석
- **제어 신호 발생:** 명령어 실행에 필요한 신호 생성
- **마이크로 명령어(micro-instruction):**
  - 각 명령어 사이클에서 실행되는 마이크로-연산 지정(제어 단어)
- **마이크로 프로그램(microprogram):**
  - 마이크로 명령어들의 집합
- **루틴(routine):**
  - CPU의 특정 기능(인출, 실행, 인터럽트 등)을 위한 마이크로 명령어 그룹

### 2.2 제어 유닛의 구조

- **명령어 해독기:** IR의 연산 코드 해독, 루틴 시작 주소 결정
- **제어 주소 레지스터(CAR):** 다음 마이크로 명령어 주소 저장
- **제어 기억장치(control memory):** 마이크로 프로그램 저장
- **제어 버퍼 레지스터(CBR):** 읽혀진 마이크로 명령어 임시 저장
- **서브루틴 레지스터(SBR):** 서브루틴 호출 시 CAR 임시 저장
- **순서제어 모듈:** 마이크로 명령어 실행 순서 결정

### 2.3 명령어 실행과 마이크로 프로그래밍

1. **명령어 종류/비트 패턴 정의**
2. **명령어 실행 하드웨어 설계**
3. **각 명령어별 실행 사이클 루틴 작성(마이크로 프로그래밍)**
4. **마이크로 프로그램을 제어 기억장치에 저장**

- **명령어 해독 및 사상(mapping):** 연산 코드를 비트 패턴과 조합해 실행 루틴 시작 주소 결정
- **마이크로 명령어 형식:**
  - 연산 필드: 마이크로 연산 지정(동시 수행 가능)
  - 조건(CD) 필드: 분기 조건 플래그(U, I, S, Z)
  - 분기(BR) 필드: 분기 종류/다음 주소 결정(JMP, CALL, RET, MAP)
  - 주소(ADF) 필드: 분기 목적지 주소

### 2.4 마이크로 프로그래밍과 순서 제어

- **마이크로 프로그래밍:**
  - 인출/간접/실행 사이클 등 다양한 동작을 마이크로 명령어 시퀀스로 구현
  - 각 루틴은 주소, 연산, 조건, 분기, 주소 필드로 구성된 2진 비트 패턴
- **순서 제어(Sequencing):**
  - 다음 마이크로 명령어 주소 결정
  - CAR 초기값은 인출 사이클 시작 주소(0)
  - MUX1: 다음 주소 선택, MUX2: 조건 플래그 선택
  - BR 값에 따라 JUMP, CALL, RET, MAP 등 분기 방식 결정

### 2.5 제어신호 생성과 마이크로 프로그래밍 방식

- **제어신호 생성:**
  - 제어 기억장치에서 인출된 마이크로 명령어의 연산 필드 비트가 제어 신호로 출력
- **수직적 마이크로 프로그래밍:**
  - 연산 필드에 적은 수의 코드화 비트(encoded bits), 해독기로 제어신호 확장
  - 장점: 명령어 짧아져 기억장치 용량 감소 / 단점: 해독 지연
- **수평적 마이크로 프로그래밍:**
  - 연산 필드 각 비트와 제어신호 1:1 대응
  - 장점: 하드웨어 단순, 지연 없음 / 단점: 명령어 길어져 기억장치 용량 증가

---

## 결론

- **정수/부동소수점 연산**의 원리와 구현, **제어 유닛** 의 구조와 동작을 논리적으로 정리
- **IEEE 754 부동소수점 표준**과 **마이크로 프로그래밍** 은 컴퓨터 아키텍처의 핵심
- 각 개념은 표, 수식, 리스트, 구분선 등 마크다운 문법으로 시각적·논리적으로 정돈
