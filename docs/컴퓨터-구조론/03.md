---
sidebar_position: 3
title: CPU의 구조와 기능(2)
---

## 1. 명령어 파이프라인

명령어 파이프라이닝은 CPU의 성능을 향상시키는 핵심 기술 중 하나입니다.<br/ >
즉, "명령어를 순차적으로 실행하는 대신, 여러 명령어를 겹쳐서 동시에 실행"하는 방식입니다.

### 1-1 2단계 명령어 파이프라인

- **인출 단계(Fetch)** 와 **실행 단계(Execute)** 로 분리
- 이론적으로 처리 속도 2배 향상 가능
- **문제점:** 두 단계의 처리 시간이 다르면 효율 저하

### 1-2 4단계 명령어 파이프라인

- 각 단계의 처리 시간을 비슷하게 맞추기 위해 파이프라인을 세분화
- **4단계:**
  1. **IF (Instruction Fetch):** 명령어 인출
  2. **ID (Instruction Decode):** 명령어 해독
  3. **OF (Operand Fetch):** 오퍼랜드 인출
  4. **EX (Execute):** 연산 수행
- **속도 향상 계산:**
  - 파이프라인 단계 수: k, 명령어 수: N
  - 전체 실행 시간: Tk = k + (N-1)
  - 파이프라인 미적용: T1 = k × N
  - 속도 향상: Sp = T1 / Tk (N이 커질수록 Sp ≈ k)
  - 예: 4단계, N=10000 → Sp ≈ 3.9988

### 1-3 파이프라인 효율 저하 요인 및 최소화 방법

- **효율 저하 요인:**
  - 모든 명령어가 모든 단계를 거치지 않음
  - 클록은 가장 오래 걸리는 단계 기준
  - 기억장치 충돌(memory conflict)
  - 조건 분기(branch) 시 미리 인출된 명령어 무효화
- **최소화 방법:**
  - **분기 예측(Branch Prediction):** 분기 발생 예측, 분기 역사 표 활용
  - **분기 목적지 선인출(Prefetch):** 분기 목적지 명령어도 미리 인출
  - **루프 버퍼(Loop Buffer):** 최근 인출 명령어를 고속 메모리에 저장
  - **지연 분기(Delayed Branch):** 분기 명령어 위치 재배치

### 1-4 상태 레지스터 (Status Register)

- 명령어 실행 결과에 따른 **조건 플래그(Condition Flag)** 저장
- 주요 플래그: 부호(S), 영(Z), 올림수(C), 동등(E), 오버플로우(V), 인터럽트(I), 슈퍼바이저(P)

### 1-5 슈퍼스칼라 (Superscalar)

- "CPU 내부에 2개 이상 명령어 파이프라인을 포함하는 구조"
- 각 파이프라인이 별도의 명령어를 동시에 실행 → 이론상 파이프라인 수만큼 속도 향상
- **속도 저하 요인:** 데이터 의존, 하드웨어 경합, 동시 실행 명령어 수 부족 등
- **해결책:** 실행 순서 재배치, 데이터 의존성 제거, 하드웨어 중복 설치 등

### 1-6 듀얼-코어 및 멀티-코어 (Multi-core Processor)

- 여러 개의 CPU 코어를 하나의 칩에 포함
- 각 코어: 슈퍼스칼라 H/W, ALU, 레지스터 등 포함
- 듀얼, 쿼드, 헥사, 옥타 코어 등
- 단일 코어 대비 2배 이상 속도 기대, 멀티태스킹/멀티스레딩 지원
- **멀티스레딩:**
  - **스레드:** 독립 실행 가능한 최소 프로그램 단위
  - **단일-스레드:** 각 코어가 하나의 스레드 처리, 레지스터 세트(RS)에 상태 저장
  - **멀티-스레드:** 각 코어가 2개 RS로 2개 스레드 처리, H/W 자원 공유

---

## 2. 명령어 세트 (Instruction Set)

명령어 세트는 "CPU를 위해 정의된 명령어들의 집합"으로, 설계에 따라 CPU의 기능과 성능이 결정됩니다.

### 2-1 명령어 세트 설계 요소

- **연산 종류:** CPU가 수행할 연산의 수, 종류, 복잡도
- **데이터 형태:** 데이터의 형태, 길이(비트 수), 수 표현 방식
- **명령어 형식:** 명령어 길이, 오퍼랜드 필드 수/길이
- **주소지정 방식:** 오퍼랜드 주소 지정 방법

### 2-2 연산의 종류

- **데이터 전송:** 레지스터/기억장치 간 데이터 이동
- **산술 연산:** +, -, ×, ÷ 등
- **논리 연산:** AND, OR, NOT, XOR 등
- **입출력(I/O):** CPU와 외부 장치 간 데이터 이동
- **프로그램 제어:** 분기, 서브루틴 호출 등
  - **CALL:** 현재 PC를 스택에 저장, 서브루틴 분기
  - **RET:** 원래 프로그램으로 복귀

### 2-3 명령어 형식

- **구성 요소:**
  - 연산 코드(opcode): 수행 연산 지정 (예: LOAD, ADD)
  - 오퍼랜드(operand): 연산 데이터/주소
  - 다음 명령어 주소: 분기/호출 시 필요
  - 필드(field): 각 요소의 비트 그룹
- **고려사항:**
  - 연산 코드 필드 길이: 정의 가능한 연산 개수
  - 오퍼랜드 필드 길이: 데이터/주소 범위, 레지스터 개수 등
- **오퍼랜드 수에 따른 분류:**
  - 1-주소: 오퍼랜드 1개 (AC 묵시적) → `ADD X ; AC <- AC + M[X]`
  - 2-주소: 오퍼랜드 2개 → `ADD R1, R2 ; R1 <- R1 + R2`
  - 3-주소: 오퍼랜드 3개 → `ADD R1, R2, R3 ; R1 <- R2 + R3`
    - 단점: 명령어 길이 증가, 해독/실행 복잡

### 2-4 주소지정 방식 (Addressing Mode)

| 방식          | 설명                                  | 장점                   | 단점             |
| ------------- | ------------------------------------- | ---------------------- | ---------------- |
| 직접          | 오퍼랜드 필드 내용이 유효 주소(EA)    | 1회 기억장치 액세스    | 지정 공간 제한   |
| 간접          | 오퍼랜드 필드가 가리키는 곳에 EA 저장 | 기억장치 용량 확장     | 2회 액세스 필요  |
| 묵시적        | 데이터 위치가 묵시적으로 지정         | 명령어 짧음            | 종류 제한        |
| 즉시          | 데이터가 명령어에 직접 포함           | 기억장치 액세스 불필요 | 상수값 크기 제한 |
| 레지스터      | 오퍼랜드가 내부 레지스터              | 필드 비트수 적음, 빠름 | 저장 공간 제한   |
| 레지스터 간접 | 레지스터 내용이 EA                    | 기억장치 영역 확장     | -                |
| 변위          | (R) + A                               | -                      | -                |
| 상대          | (PC) + A, 주로 분기                   | -                      | -                |
| 인덱스        | (IX) + A, 배열/자동 인덱싱            | -                      | -                |
| 베이스        | (BR) + A, 위치 지정/변경              | -                      | -                |

### 2-5 실제 상용 프로세서들의 명령어 형식

- **CISC:** 명령어 수 많음, 길이 불규칙, 다양한 주소지정 (예: Intel 펜티엄)
- **RISC:** 명령어 수 최소화, 길이 고정, 단순 주소지정 (예: ATmega, ARM)
- **PDP-10:** 36비트 고정 길이
- **PDP-11:** 다양한 길이
- **펜티엄:** 선형 주소(Linear Address, LA = (SR) + EA), 다양한 주소지정
- **ATmega:** 8비트 RISC, 대부분 16비트 명령어, 32비트 기억장치 액세스 명령어
- **ARM:** 32비트 RISC, Thumb(16비트) 명령어 지원, 모바일에 널리 사용

> 참고: 인텔 개발자 매뉴얼(Intel® 64 and IA-32 Architectures Software Developer Manuals)에서 상세 정보 확인 가능
