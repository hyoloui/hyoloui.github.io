---
sidebar_position: 16
title: 백 트레킹
description:
---

## 1. 백트래킹(Backtracking)

백트래킹은 '되돌아가다' 또는 '되짚어 가다'의 의미를 가지는 '되추적 검색' 또는 '퇴각 기법'으로 불리는 알고리즘입니다. 제약 조건 만족 문제(constraint satisfaction problem)에서 해를 찾기 위한 방법으로, 문제 해결 과정에서 더 이상 경로를 통해 갈 수 없거나 이미 경로를 다 가봤을 경우, 혹은 새로운 경로를 찾아야 할 때 이전 분기점으로 되돌아가는 특징을 가집니다.

1.1. 개념 및 작동 원리
기본 개념

: "해를 찾기 위해 후보군에 제약 조건을 점진적으로 체크하다가, 해당 후보군이 제약 조건을 만족할 수 없다고 판단되는 즉시 되돌아 감" (학습정리 summary). 확인했던 후보군은 다시 체크하지 않고, 다른 후보군으로 넘어가 최적의 해를 찾습니다.
미로 찾기 예시
:

분기점이 나올 때까지 길을 따라갑니다.

분기점을 만나면 한 길을 선택하여 표시하면서 진행합니다.

길이 막혀 있다면 직전 분기점까지 되돌아갑니다.

시도하지 않은 다른 길을 선택하여 다시 진행합니다.

모든 길을 시도했다면 직전 분기점까지 되돌아간 후 시도하지 않은 길부터 시작합니다.

깊이 우선 탐색(DFS)과의 연관성
: 백트래킹은 연결된 노드를 따라 최대한 깊게 들어가는 "깊이 우선 탐색(DFS : Depth-First Search)" 방식을 활용합니다. 이는 상태 변화를 추적하기 용이하기 때문입니다.
1.2. 백트래킹 상태 및 상태 공간 트리
백트래킹 상태: 문제를 해결해나가는 과정에서 특정 순간의 모습을 의미하며, 시작 상태에서 출발하여 주어진 규칙에 따라 상태를 변화시키고 최종 상태에 도달하면 종료됩니다. "최종 상태는 ‘후보해(candidate solution)’라 부르기도 함."
예시: 배낭 문제(어떤 물건들이 들어있고 총 가치와 무게를 계산함), 오목 게임(게임 중 한 순간의 바둑판 모습).
상태 공간 트리(State Space Tree): '가능한 모든 상태'를 시각적으로 표현한 트리 구조입니다. 시작 상태에서 천이(transition)가 가능한 이후 상태를 자식 노드로 연결하고, 이 과정을 최종 상태에 이르기까지 반복합니다.
노드의 종류:
유망한 노드 (promising node): "해답을 얻기 위해 자식 노드로 진행할 필요가 있음." 즉, 현재 경로가 해답으로 이어질 가능성이 있는 노드입니다.
유망하지 않은 노드 (nonpromising node): "자식의 상태를 확인할 필요가 없음." 현재 경로가 해답으로 이어질 가능성이 없어 더 이상 탐색할 필요가 없는 노드입니다.
가지치기 (Pruning): "유망하지 않은 노드를 가능한 많이 걸러내는 전략이 중요함." "조건에 맞지 않으면 포기하고 다른 루트로 바로 돌아서서 탐색의 시간을 절약하는 기법" (학습정리 summary). 이는 탐색 시간을 절약하는 핵심적인 기법입니다.
1.3. 백트래킹 알고리즘 구조
탐색 방식: 상태 공간 트리의 탐색은 DFS 방식으로 이루어지며, "각 후보군을 DFS 방식으로 확인함." (학습정리 summary)
가지치기 적용: promising(v) 함수를 통해 노드의 유망성을 판단하고, 유망하지 않으면 해당 분기(sub-tree)를 더 이상 탐색하지 않고 되돌아갑니다.
메모리 관리: 순환 함수 호출 시 변하는 값만 파라미터로 넘기고, 변하지 않는 변수는 전역 변수로 선언하여 메모리 낭비를 줄입니다. 실제 상태 공간 트리를 만드는 대신 탐색하는 노드의 상태를 배열에 기록하고 추적합니다.

## 2. N-여왕(N-Queen) 문제

N-여왕 문제는 "𝑛 × 𝑛 체스판에서 n개의 여왕을 서로 공격할 수 없도록 배치하는 문제"입니다. 즉, 어떤 두 여왕도 같은 행, 같은 열, 같은 대각선상에 위치할 수 없도록 해야 합니다. N이 4 이상일 때만 해가 존재합니다.

2.1. 문제 정의 및 예시
제약 조건: 여왕은 가로, 세로, 대각선 방향으로 공격할 수 있습니다. 따라서, N개의 여왕은 서로의 공격 범위에 놓이지 않아야 합니다.
4-여왕 문제 예시: 4x4 체스판에 4개의 여왕을 배치하는 과정을 통해 백트래킹의 작동 방식을 시각적으로 보여줍니다. "상태 공간 트리를 통해 n = 4일 때, 2가지 해답 노드가 있음을 확인할 수 있음."
2.2. 백트래킹을 이용한 해결
상태 공간 트리 관리: 배열을 사용하여 상태 공간 트리를 관리합니다. 배열의 인덱스는 행을 나타내고, 배열 값은 해당 행에 놓인 여왕의 열을 나타냅니다.
유망성 판단: 특정 좌표 (x, y)에 퀸을 둘 수 있는지 판단하기 위해 다음 세 가지 배열을 사용합니다.
beontour1[y]: 열 y에 퀸이 존재하는지 확인 (열 중복 방지).
beontour2[x + y]: 좌측 하단과 우측 상단을 잇는 대각선에 퀸이 존재하는지 확인 (대각선 중복 방지).
beontour3[x - y + n - 1]: 좌측 상단과 우측 하단을 잇는 대각선에 퀸이 존재하는지 확인 (대각선 중복 방지).
qFunc(current) 함수는 current 번째 행에 퀸을 배치할 수 있는지 확인하고, 가능한 경우 다음 행으로 재귀 호출합니다.
분석:
상태 공간 트리의 노드 수 (최악의 경우): (n^(n+1) - 1) / (n - 1). 4-여왕 문제의 경우 341개, 8-여왕 문제의 경우 19,173,961개입니다.
유망한 노드 수 (최대): 1 + n + n(n-1) + ... + n!. 4-여왕 문제의 경우 최대 65개, 8-여왕 문제의 경우 최대 109,601개입니다.
실제 방문하는 노드의 수: 백트래킹의 가지치기 효과로 인해 DFS로 방문하는 전체 노드 수보다 훨씬 적습니다. 예를 들어, 8-여왕 문제의 경우 DFS는 15,721개의 노드를 방문하지만, 백트래킹은 2,057개의 유망한 노드만 방문합니다.

## 3. 해밀턴 사이클(Hamiltonian Cycle)

해밀턴 사이클은 연결된 그래프에서 "모든 정점을 단 한번만 지나는 경로"인 해밀턴 경로가 출발 정점으로 돌아와 사이클을 구성하는 경로를 의미합니다. 간선 가중치가 없는 비방향성 그래프에서 해밀턴 사이클이 존재하는지 여부를 확인하는 결정 문제입니다.

3.1. 문제 정의 및 상태 공간 트리
해밀턴 경로: 그래프의 모든 정점을 단 한 번만 지나는 경로.
해밀턴 사이클: 한 정점에서 출발하여 다른 정점을 한 번씩만 방문하고 출발 정점으로 돌아오는 경로.
상태 공간 트리:
가정: 간선 가중치가 없는 비방향성 그래프, 정점은 1~n, 출발점은 1.
레벨 0의 루트 노드는 정점 1을 방문한 상태입니다.
레벨 i의 노드들은 출발점에서 i번째까지 방문한 정점들의 경로를 나타냅니다.
각 노드의 자식 노드 수는 n - 1개입니다.
3.2. 유망하지 않은 노드 판별
다음 3가지 조건 중 어느 하나라도 만족하지 않으면 유망하지 않은 노드로 판단하여 가지치기를 수행합니다.

출발점으로부터 i번째 방문한 정점이 i - 1번째 방문한 정점과 인접하지 않음.
단말 노드에 나타나는 n - 1번째 방문한 정점이 출발점과 인접하지 않음.
출발점으로부터 i번째 방문한 정점은 이미 방문한 i - 1개의 정점 중 하나임 (즉, 중복 방문).
3.3. 백트래킹 알고리즘 및 분석
상태 관리: 1차원 배열을 사용하여 상태 공간 트리를 관리합니다. 배열 인덱스는 방문 순서를 나타내고, 배열 값은 해당 순서에서 방문한 정점을 저장합니다.
분석:
상태 공간 트리의 노드 수 (최악의 경우): 1 + (n-1) + (n-1)^2 + ... + (n-1)^(n-1). 4-정점 문제의 경우 40개, 8-정점 문제의 경우 960,800개입니다.
유망한 노드 수: N-여왕 문제와 달리 입력 그래프에 따라 유망한 노드의 수가 달라지므로 일반적인 계산식이 없습니다. "빠르게 해답을 얻을 수도 있고 상태 공간 트리를 모두 탐색해야 할 수도 있음."

## 4. 그래프 채색(Graph Coloring)

그래프 채색은 "정점, 간선, 면을 기준으로 인접한 구성 요소가 같은 색이 되지 않도록 색칠하는 문제"입니다. 일반적으로 '정점 채색'을 의미하며, 인접한 두 정점이 같은 색을 갖지 않도록 모든 정점을 칠하는 문제입니다.

4.1. 문제 정의 및 상태 공간 트리
정점 채색: 인접한 두 정점이 같은 색을 갖지 않도록 모든 정점을 칠하는 문제.
간선 채색: 선 그래프(line graph)에 대한 정점 채색 문제로 변환 가능.
면 채색: 이중 그래프(dual graph)에 대한 정점 채색 문제로 변환 가능.
루프를 가지는 정점: 채색이 불가능합니다.
목표: 최대 n개의 서로 다른 색을 가지고 정점 채색이 가능한지 확인하는 결정 문제입니다. 어떤 색으로 칠하는가는 중요하지 않으며, 색은 1, 2, 3과 같은 정수로 표현됩니다.
상태 공간 트리:
시작은 아무것도 칠하지 않고 비어있는 지도에서 출발합니다.
레벨 i의 노드들은 정점 1에서부터 차례대로 정점 i까지 채색한 상태를 나타냅니다.
단말 노드의 레벨은 n입니다.
유망하지 않은 노드 판별: 인접한 정점은 같은 색으로 칠하면 안 된다는 제약 조건을 위반할 경우 가지치기를 합니다.
그래프 채색 문제는 결정 문제이므로 해답 노드를 발견하면 실행을 멈춥니다.
4.2. 백트래킹 알고리즘 및 분석
상태 관리: 1차원 배열을 사용하여 상태 공간 트리를 관리합니다. 배열 인덱스는 방문 순서를 나타내고, 배열 값은 해당 순서에서 방문한 정점의 색을 저장합니다.
분석:
상태 공간 트리의 노드 수: (k^(n+1) - 1) / (k - 1) (여기서 k는 사용할 수 있는 색의 개수). 결정 문제이고 효율적 가지치기가 이루어지므로 실제 방문 노드 수는 훨씬 적습니다.
유망한 노드 수: 해밀턴 사이클 문제와 유사하게 입력 그래프에 따라 유망한 노드의 개수가 달라지므로 일반적인 계산식이 없습니다.
4.3. 응용 분야
컴파일러에서 레지스터 할당: 코드 최적화를 위해 사용됩니다. 변수를 정점으로, 동시에 필요한 변수들을 간선으로 연결한 간섭 그래프를 구축하여 최대 n개의 레지스터에 저장이 가능하도록 모델링합니다.
스도쿠: 가로, 세로, 3x3 작은 사각형 내에서 숫자가 겹치지 않도록 채우는 문제입니다.
다양한 스케줄링 문제: 각 작업에 동일한 시간을 할당한다고 가정할 때, 각 작업을 정점으로 하고 겹쳐서 진행할 수 없는 작업들을 간선으로 연결한 그래프로부터 최소 완료 시간을 구할 수 있습니다.

## 5. 브루트 포스(Brute Force)

브루트 포스는 "완전 탐색 알고리즘이며 가능한 모든 경우의 수를 탐색하며 해를 찾아냄" (학습정리 summary)을 의미합니다. "알고리즘의 가장 기본적인 접근 방법은 해가 존재할 것으로 예상되는 모든 영역을 전체 탐색하는 기법"입니다.

5.1. 개념 및 해결 방법
기본 개념: 모든 가능한 경우의 수를 탐색하여 해를 찾는 단순하고 직접적인 방법입니다. '단순법'이라고도 불리며, 선형 검색을 단순하게 확장한 알고리즘입니다.
해결 단계:
주어진 문제를 선형으로 구조화합니다.
구조화된 문제 공간을 적절한 방법으로 해를 구성할 때까지 탐색합니다.
구성된 해를 정리합니다.
문자열 검색 예시: 어떤 문자열(텍스트) 안에 특정 문자열(패턴)이 들어 있는지 검사하고, 포함되어 있다면 그 위치를 찾습니다. 텍스트의 각 위치에서 패턴의 모든 문자와 일치하는지 순차적으로 비교합니다.
5.2. 장점 및 종류
장점:
구현하기가 쉽습니다.
정답 확률이 높습니다 (모든 경우의 수를 탐색하므로).
종류: 자료구조에 따라 탐색 방법이 다릅니다.
선형구조 탐색: 순차 탐색 (Sequential Search).
비선형구조 탐색: DFS (Depth-First Search), BFS (Breadth-First Search).
5.3. 시간 복잡도
문자열 검색의 경우, 텍스트의 길이를 n, 패턴의 길이를 m이라고 할 때 최악의 경우 시간 복잡도는 O(mn)입니다. 하지만 패턴이 텍스트 내에 존재하지 않거나 짧은 경우 O(n)에 가까울 수 있습니다. "단순한 알고리즘이지만 실제로는 아주 빠르게 동작함."
이 문서는 제공된 자료의 핵심 내용을 정리하고, 각 알고리즘의 정의, 작동 방식, 관련 개념, 그리고 N-여왕, 해밀턴 사이클, 그래프 채색, 브루트 포스 문제에 적용되는 방식 및 그 특성을 상세히 다루었습니다.
